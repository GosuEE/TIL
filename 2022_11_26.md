# 리액트 기초

jsx 문법에선 laber <u>for</u>나 h1 <u>class</u>=""같은 키워드를 사용하면 안된다. 이유는 for, class같은 단어는 자바스크립트의 예약어이기 때문에 사용했다가는 오류가 생길 수 있기 때문이다.

따라서 for, class 대신 <strong>htmlFor</strong>, <strong>className</strong>을 사용해주어야 한다.
***
input태그의 인풋에 변화가 생겼을 때 onChange 속성을 이용해 이벤트 리스너를 추가할 수 있다.
```javascript
<input vlaue ={minutes} id="minutes" placeholder="Minutes" type="number" onChange={onChange} />
```
변화가 일어났을때 호출하는 onChange함수에 event 인자를 넣어주면 이벤트에 접근이 가능하다.
```javascript
const onChange = (event) => {
    console.log(event)
}
```
event에서 변화가 일어난 값을 가져오고 싶다면(위의 상황에서는 value가 될 것이다.) event.target.value로 접근할 수 있다.
```javascript
const onChange = (event) => {
    console.log(event.target.value)
}
```
위와 같은 방식을 이용해 js에서 form을 사용할 수 있다.
***
disabled 속성을 이용하여 /<input>, /<select>, /<textarea>, /<button>, /<option>, /<optgroup>,/<fieldset> 태그들을 사용 못하게 막아놓을 수 있다. 또한 jsx에서 disabled 속성은 값으로 진리값을 가질 수 있는데 true면 비활성, false면 활성화된다.

```html
<input value={minutes} id="minutes" placeholder="Minutes" type="number" onChange={onChange} disabled=false/>
<input value={minutes / 60} id="hours" placeholder="Hours" type="number" disabled=true/>
```
minutes는 활성, hours는 비활성 된 상태이다.
***
컴포넌트는 <컴포넌트 이름 />을 통해 다른 컴포넌트를 렌더링 할 수 있다.

부모 컴포넌트에서 자식 컴포넌트를 렌더링 할 때 <컴포넌트 이름 변수 이름=데이터 />로 자식 컴포넌트에게 데이터를 전달할 수 있다. (ex. <Btn text="hello"/>)

jsx문법에서 컴포넌트는 함수이기 때문에 함수에 인자를 전달한 것과 같은 기능을 한다. 즉, <Btn text="hello"/>는 Btn({text:"hello"})와 같은 역할을 한다.

Btn 함수에서 전달받은 인자들을 사용해야 하므로 Btn함수는
```javascript
Btn(props){
// do something
}
```
과 같이 정의될것이고, 전달받은 인자를 props라고 부른다.

<Btn text="hello"/>에 이벤트 리스너를 달기 위해 <Btn text="hello" onClick={changeValue}/>와 같이 코드를 작성해서는 안된다. 컴포넌트를 렌더링 할 때 뒤에 작성된 코드들은 리액트가 전부 props로 인지하므로 이벤트 리스너를 달기 위해서는 원래 컴포넌트를 정의하는 함수에 추가로 작성해야한다.
```javascript
function Btn(props) {
return (<button
    onClick={props.onClick}
    style={{
        backgroundColor: "tomato",
        color: "white",
        padding: "10px 20px",
        border: 0,
        borderRadius: 10,
    }}>{props.text}</button>
)
}

function App() {
const [value, setValue] = React.useState("hello")
const changeValue = () => setValue("hi");
return (
    <div>
        <Btn text={value} onClick={changeValue}/>
        <Btn text="bye"/>
    </div>
)
};
const root = document.getElementById("root")
ReactDOM.render(<App />, root);
```
위와 같이 작성하면 된다.

그러나 위와 같은 방식은 상위 컴포넌트에 state를 설정했고, 그 state를 변경하는 changeValue 함수를 선언하고 이를 props로 하위 컴포넌트에 넘겨 준 뒤 하위 컴포넌트에서 onClick으로 해당 함수를 실행하면 상위 컴포넌트의 상태가 바뀌므로 존재하는 모든 하위 컴포넌트를 재 렌더링하게되는 현상이 발생한다.

이를 해결하기 위해 React Memo라는 것을 사용하여
```javascript
function Btn(props) {
return (<button
    onClick={props.onClick}
    style={{
        backgroundColor: "tomato",
        color: "white",
        padding: "10px 20px",
        border: 0,
        borderRadius: 10,
    }}>{props.text}</button>
)
}

const MemorizedBtn = React.memo(Btn) // React.memo를 사용해 새로운 MemorizedBtn 생성
function App() {
const [value, setValue] = React.useState("hello")
const changeValue = () => setValue("hi");
return (
    <div>
        <MemorizedBtn text={value} onClick={changeValue} /> // MemorizedBtn 렌더링
        <MemorizedBtn text="bye" /> // MemorizedBtn 렌더링
    </div>
)
};
const root = document.getElementById("root")
ReactDOM.render(<App />, root);
```
다음과 같이 수정해주면 부모 컴포넌트에서 변경 된 MemorizedBtn만 렌더링된다.
