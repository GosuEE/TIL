# JS 과제입니다.

## JavaScript의 자료형과 JavaScript만의 특성은 무엇일까 ? 

- 느슨한 타입(loosely typed)의 동적(dynamic) 언어

느슨한 타입은 변수의 타입을 명확하게 지정하지 않음을 의미합니다. 따라서 변수 생성시 변수의 타입을 미리 선언하지 않습니다.

자바스크립트의 변수는 모든 값으로 할당 및 재할당 가능합니다.

- JavaScript 형변환

자바스크립트는 타입에 구애받지 않기 때문에 자바스크립트 엔진이 필요한 경우 암시적 변환을, 개발자가 명확히 타입을 지정하고 싶은 경우 명시적 변환을 실행합니다.

예를 들어, 자바스크립트는 연산자의 종류에 따라 암시적인 형변환을 시행합니다. 더하기 연산자의 경우 숫자보다 문자열이 우선시 되기 때문에 문자열과 숫자의 덧셈이 발생할 경우 암시적으로 숫자를 문자열로 형변환하게 됩니다.

```
number + number // number
number + string // string
string + string // string
string + boolean // string
number + boolean // number
```

- ==, ===

'=='는 단순히 값을 비교합니다. 예를 들어 0=="0", 0==[]과 같은 식은 true를 리턴합니다.

그러나 '==='는 비교하는 변수들의 타입까지 고려합니다. 양쪽 변수의 타입이 다르면 false를 리턴합니다.

특수한 상황이 아니면 ===가 권장됩니다.

- 느슨한 타입(loosely typed)의 동적(dynamic) 언어의 문제점은 무엇이고 보완할 수 있는 방법에는 무엇이 있을지 생각해보세요.

변수의 타입이 명확하게 지정되지 않기 때문에 코드 작성중 개발자가 의도하지 않은 값이 변수에 할당될 수 있습니다. 동적 타입 언어는 변수의 타입을 컴파일 시간이 아닌 실행 시간에서 확인하기 때문에 이를 미리 알 수 없고 코드가 길어지면 변수 타입에 의해 발생한 에러를 파악하기가 어려워집니다.

이를 보완하기위해 나온 언어가 typescript입니다. 타입스크립트는 명확하게 변수의 자료형을 지정하기 때문에 디버깅하기 조금 수월합니다.

- undefined와 null의 미세한 차이들을 비교해보세요.

undefined는 변수가 선언이 되었으나 아무런 값도 저장되지 않은 상태이고, null은 빈 객체를 의미합니다.

## JavaScript 객체와 불변성이란 ? 

- 기본형 데이터와 참조형 데이터

자바스크립트의 기본형 데이터는 boolean int double char만이 존재하고 나머지 모든 변수는 참조형입니다.

- JavaScript 형변환

실제로 코딩시에 숫자와 스트링 캐릭터 사이에서 명시적 형변환을 해야할 상황은 많이 발생합니다. 자바스크립트의 암시적 형변환을 이용하여 형변환 할 수도 있고, 각종 함수를 이용하여 형변환을 할 수도 있습니다.

1. int to char

사실 자바스크립트에는 char변수형이 존재하지 않습니다. 하나의 문자도 무조건 문자열로 처리합니다.

정수에서 아스키코드를 이용한 스트링으로 변환은

```
String.fromCharCode(value)
```
를 이용하면 됩니다.

2. int to String

value += "" (암시적 형변환을 이용)

```
var value = 123
value.toString(); (명시적 형변환을 이용)
```

3. double to String

```
val value = 123.456
value.toFixed(3)
```

toFixed(n)은 n+1번째에서 반올림하고 n자리까지만 문자열로 변환하는 함수입니다.

4. String to Number

```
var value = "3"
var value *= 1
```

자바스크립트의 암시적 형변환을 이용하여 String을 Number로 변환할 수 있습니다. String * Number의 값은 Number임을 이용한 것입니다.

```
var value = "3"
value = Number(value)
```

타입 변환을 하는 함수를 이용한 방식입니다.

- 불변 객체를 만드는 방법

const와 Object.freeze()를 이용하는 방법이 있습니다.

const 키워드로 선언된 변수는 재할당을 할 수가 없습니다. 그러나 객체 내부의 프로퍼티 변경은 가능합니다.
Object.freeze로 동결된 객체는 프로퍼티를 변경할 수 없습니다. 그러나 변수에 재할당은 가능합니다.
따라서 둘을 적절히 조합하여
```javascript
const value = {
	this.name = "obj"
};
Object.freeze(value)
```
다음과 같이 사용하면 됩니다.

- 얕은 복사와 깊은 복사

얕은 복사는 객체가 가지고 있는 주소를 참조하기만 합니다. 따라서 원래 객체가 변경된다면 얕은 복사를 한 객체도 변경됩니다.

깊은 복사는 객체와 인스턴스 변수를 모두 복사합니다. 전부 복사하여 새 주소에 담기 때문에 원래 객체가 변경되어도 새로운 객체는 변경되지 않습니다.

## 호이스팅과 TDZ는 무엇일까 ?

- 스코프, 호이스팅, TDZ

스코프는 변수에 접근할 수 있는 범위를 의미합니다. 대부분의 C like언어는 블록 스코프를 사용하나 자바스크립트는 함수 스코프를 사용합니다. 다만 let 키워드를 이용하면 블록 스코프를 사용할 수 있습니다.

호이스팅이란 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미합니다. 따라서 호이스팅된 변수와 함수는 선언 이전에도 접근이 가능해집니다.

변수 호이스팅은 var로 선언되었을 경우에만 실행됩니다.

호이스팅은 선언에서만 실행되고 대입에서는 실행되지 않습니다. 예를들어
```javascript
console.log(value) // undefined
var value;
value = 1
```
위의 코드에서 대입은 호이스팅이 실행되지 않기 때문에 undefined가 출력됩니다.

TDZ는 Temporal Dead Zone를 의미합니다. TDZ때문에 클래스나 let,const 변수가 선언되기 전까지는 접근할 수 없습니다.

- 함수 선언문과 함수 표현식에서 호이스팅 방식의 차이

함수 선언문은 호이스팅의 대상이 되고 함수 표현식은 그렇지 않습니다. 즉 함수 선언문으로 정의된 함수는 선언 전에 접근이 가능하고 함수 표현식으로 정의된 함수는 선언 전에 접근할 수 없습니다.

- 여러분이 많이 작성해온 let, const, var, function 이 어떤 원리로 실행되는지 알 수 있어요.

let, const: 호이스팅x, 블록 스코프

var: 호이스팅o, 함수 스코프

function: 선언 방식에 따라 호이스팅이 되는지가 결정됩니다.

- 실행 컨텍스트와 콜 스택

실행 컨텍스트란 코드를 실행하기 위해 필요한 정보들을 가진 범위를 객체 형태로 나타낸 것입니다. 자바스크립트에서 실행 컨텍스트를 만드는 방법은 다음과 같습니다.
```
전역 코드 : 전역 영역에 존재하는 코드
Eval 코드 : eval 함수로 실행되는 코드
함수 코드 : 함수 내에 존재하는 코드
(ES6부터는) 블록문
```

실행 컨텍스트가 생성이 되면 자바스크립트는 해당 코드에 대한 환경 정보를 수집해서 실행 컨텍스트에 저장한 뒤 콜 스택에 푸쉬합니다. 블록문이 끝나거나 함수의 값이 반환되면 콜 스택에서 팝을 합니다.

콜 스택을 이용하여 맨 위에 있는 함수 컨텍스트가 현재의 상태임을 특정할 수 있습니다.

- 스코프 체인, 변수 은닉화

스코프 체인은 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 저장하고 스코프가 어떻게 연걸되고 있는지를 보여주는 것입니다. 스코프 체인은 함수가 선언될 때 저장되고 이를 렉시컬 스코프라고 말합니다.

특정 스코프에서 변수를 접근하면, 자신의 스코프에 해당 변수를 찾아봅니다. 자신의 스코프에 변수가 없다면 인접 스코프, 또 없으면 그 인접 스코프..를 반복하고 전역 스코프에도 해당 변수가 없으면 refrence error가 발생됩니다.

## 실습 과제

- 콘솔에 찍힐 b 값을 예상해보고, 어디에서 선언된 “b”가 몇번째 라인에서 호출한 console.log에 찍혔는지, 왜 그런지 설명해보세요.
주석을 풀어보고 오류가 난다면 왜 오류가 나는 지 설명하고 오류를 수정해보세요.

```javascript
let b = 1;

function hi () {

const a = 1;

let b = 100;

b++;

console.log(a,b); 

}

//console.log(a); a의 스코프는 function hi()이므로 hi의 밖에서는 접근이 불가능합니다.

console.log(b); // 1

hi(); // 1, 101

console.log(b); // 1
```

- 두 값이 다른 이유를 설명해보세요.

```javascript
1 == "1"; // true
1 === "1"; // false
```

'=='연산자는 들어있는 값만을 비교하므로 ture를 반환하고
'==='연산자는 타입까지 비교하므로 false를 반환합니다.
