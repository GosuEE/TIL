# 목터뷰(기술면접 준비)

## 1. 시간복잡도와 공간복잡도가 무엇인지 설명해주실 수 있을까요?

시간복잡도는 프로그램의 입력값과 `연산(산술, 대입, 비교, 이동)` 수행 시간의 상관관계를 나타내는 척도이다.

시간복잡도는 주로 `Big O(빅-오)`표기법을 사용해서 나타낸다. Big-O 표기법은 알고리즘이 <b>해당 차수이거나, 그보다 낮은</b>s 차수의 시간복잡도를 가진다는 의미이다.

데이터의 크기(n)가 커질수록 Big-O `복잡도가 큰` 알고리즘이 언젠가는 `복잡도가 작은` 알고리즘을 <b>연산 횟수에서 역전</b>한다는 수학적인 사실이 있으므로 Big-O 복잡도가 최악의 상황에서의 시간 복잡도를 나타내기에 적당해 사용된다.

`공간복잡도`는 프로그램의 입력값과 프로그램이 완료될 때까지 필요로 하는 자원 공간(메모리)의 양을 의미한다.

간단히 예를 들어보면 <b>비교기반 정렬 알고리즘</b>의 시간복잡도는 `O(nlogn)`보다 개선될 수 없다. 그러나 비교기반 정렬 알고리즘이 아닌 `Radix sort`는 `O(kn)`의 시간복잡도를 가지게 된다.(k는 데이터의 자릿수) 그러나 비교 기반 정렬인 `Quick sort`의 공간 복잡도는 `O(logn)`, `Radix sort`는 `O(k+n)`이 필요하고, Radix sort는 여러가지 제한사항이 따르므로 <b>실제로는 비교 기반 정렬 알고리즘이 더 자주 사용</b>된다.

## 2. 스택, 큐에 대해 설명해주실 수 있을까요?

스택과 큐는 모두 선형 자료구조이다. 둘의 가장 큰 차이점은 Stack은 <b>LIFO(Last In First Out)</b>이고 Queue는 <b>FIFO(First In First Out)</b>이다.

## 3. 배열, 링크드리스트를 비교하여 설명해주실 수 있을까요?

배열은 데이터들이 메모리 공간에서 <b>연속적</b>으로 저장되어있는 자료구조이다. 메모리 상에서 연속적으로 저장되어 있기 때문에 `index`를 통한 접근이 용이하다.

연결 리스트는 여러개의 노드들이 <b>순차적으로 연결</b>된 형태를 갖는 자료구조이다. 각 노드는 `포인터`를 통해 다음/이전 노드를 가리킨다. 메모리를 연속적으로 사용하지 않기 때문에 배열에 비해서 <b>접근에 불리</b>하지만 <b>삽입, 삭제에는 용이</b>하다.

## 4. CORS란 무엇이고 어떻게 허용할 수 있나요?

`CORS`는 <b>교차 출처 리소스 공유</b>의 줄임말이다. 브라우저의 동일 출처 정책을 위반하면 CORS 에러가 발생하게 된다. 여기서 `프로토콜, 호스트, 포트`가 모두 같을 때 브라우저는 동일 출처라고 인식하고, 셋 중 하나만 다르더라도 브라우저에서는 CORS에러를 띄우게 된다.

CORS에러를 해결하는 방법은 크게 세 가지가 있다.

- 브라우저의 동일 출처 정책을 끈다<b>(이런 짓은 하면 안됩니다)</b>
- 모든 출처를 허용하는 프록시 서버를 구축한다
- 서버에서 Access-Control-Allow-Origin 헤더에 접속하고자 하는 출처를 세팅해서 클라이언트로 전송한다

## 5. 사용자 패스워드를 전송하고 보관하는 방법을 설명해주실 수 있을까요?

클라이언트에서 서버로 평문을 보내고 단방향 해시 함수를 통해 원본 데이터를 암호화된 데이터로 변환하여 해당 데이터를 서버에 보관하게 된다.

해시 함수를 통해 생성된 데이터(다이제스트)를 통해 원본 데이터를 구할 수 없고, 원본을 통해서는 다이제스트를 구할 수 있으므로 단방향 해시 함수라고 부른다. 단방향 해시 함수의 특성상 다이제스트를 안다고 원본을 알 수는 없기 때문에 비밀번호의 암호화에 사용된다.

## 6. var, let, const 에 대해 설명해주실 수 있을까요?

var: 변수에 재할당이 가능하며, 심지어 재선언도 가능한 변수 선언 방식이다. (현재는 잘 사용되지 않는다)
let: 변수에 재할당이 가능하지만 재선언은 불가능하다.
const: 재할당과 재선언 모두 불가능하다.

var로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 따라서 var로 선언된 변수는 선언문 이전에 참조가 가능하다. 하지만 let과 const는 스코프의 시작에서 변수의 선언까지 TDZ에 빠지기 때문에 선언 이전에 변수에 접근을 하면 오류가 발생한다.

## 7. Promise란 무엇인지 설명해주실 수 있을까요?

Promise는 코드의 동기적 진행을 위해 추가된 객체이다. Promise가 나오기 전엔 콜백함수를 이용해 코드를 동기적으로 진행시켰으나 이는 콜백지옥을 야기하였고 가독성에 심각한 문제를 초래하였다.

then(), catch(), finally() 메소드를 통해 완료 상태와 실패 상태에서 각기 다른 콜백함수를 처리할 수 있다.

또한 프로미스는 프로미스 체이닝을 통해 여러개의 콜백함수를 처리할 수 있는데, 여러개의 프로미스가 중첩되면 이 역시 코드의 가독성을 해치는 문제가 발생하여 async와 await 키워드를 통해 결과값을 얻을 수 있을 때 까지 기다림으로써 일반적인 동기 코드 처리와 동일한 흐름으로 코드를 작성할 수 있게 하였고 코드의 가독성도 좋아지게 작성을 할 수 있게 되었다.

## 8. Hoisting이란 무엇인지 설명해주실 수 있을까요?

JavaScript에서 호이스팅(hoisting)이란, 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미한다. 코드를 실행하기 전에 실행 컨텍스트를 구축하기 위한 과정에서 모든 선언들을 스코프에 등록하기 위해 인터프리터는 호이스팅을 진행한다.

자바스크립트에서는 초기화가 아닌 선언만 호이스팅된다. 따라서 var, let, const, class, 화살표 함수, function등 모든 선언은 호이스팅되나 let, const, class와 같은 키워드들은 호이스팅이 발생하지 않는 것 처럼 동작하는데 이는 해당 키워드로 선언된 변수나 class들이 스코프의 시작에서 변수의 선언까지 TDZ에 빠지기 때문이다.

## 9. async/await 이란 무엇인지 설명해주실 수 있을까요?

async를 붙이면 해당 함수는 항상 프로미스를 반환한다. 프로미스가 아닌 값을 반환하더라도 이행 상태의 프로미스로 값을 감싸 이행된 프로미스가 반환되도록 한다. async함수에서 에러를 발생 시킬 때에는 throw를 사용하고 에러를 처리하기 위해서는 try/catch를 이용한다.

자바스크립트는 await 키워드를 만나면 프로미스가 처리될 때까지 기다린다. await 키워드는 프로미스 앞에만 붙일 수 있고, 프로미스가 resolve됐을 때의 값을 return한다. await 키워드는 반드시 async 키워드와 같이 선언된 함수 내에서만 사용되어야한다.

## 10. 개발자로서 본인의 장단점과 근거가 되는 경험을 말씀해주실 수 있을까요?(협업 능력 제외)

저는 프로그램의 성능을 개선시키는데 흥미가 있다. 프로젝트 경험 과정에서 함수 호출 오버헤드를 줄여 알고리즘의 작동시간을 평균 850ms => 41ms로 개선 시킨 경험이 있다.

또한 자료구조, 알고리즘, 이산수학, 계산이론등 수학과 전산학에 관련된 흥미가 있다. 문제를 해결하기 위해 적절한 자료구조가 무엇인지 판단할 수 있고 수학적인 방법을 사용해 문제를 해결하는것을 좋아한다.

예를 들어 프로젝트 진행 과정에서 남은 시간을 표시하는 원형 타이머를 구현해야 하는 문제가 있었다. (현재 시간-최초 시간) / 최대 시간을 계산해서 부채꼴의 중심각을 구하고, 원의 중심 좌표와 반지름, 중심각을 이용해 삼각함수로 현재의 x좌표와 y좌표를 구해 svg의 path를 통해 호와 삼각형을 그려 구현했다.

## 11. Arrow Function 이란 무엇인지 설명해주실 수 있을까요?

전통적인 함수 선언과 비슷하게 인자를 받고, 블록 내의 코드를 진행시키며 원하는 값을 return할 수도 있지만 몇 가지의 차이점이 있다.

- this나 super에 대한 바인딩이 없고, 메소드로 사용 불가
- call, apply, bind 메소드 사용 불가
- 생성자로 사용할 수 없음
- 함수 실행시에 arguments 변수가 전달되지 않음

## 12. ‘==’와 ‘===’ 연산자의 차이는 무엇인지 설명해주실 수 있을까요?

'=='는 값만 비교하고, '==='는 값을 비교함과 동시에 유형도 확인한다.

예를 들어, 0 == '0'은 true지만, 0 === '0'은 false를 리턴한다.

## 13. Virtual DOM이란 무엇이고 Real DOM과의 차이는 무엇인가요?

DOM은 Document Object Model의 줄임말로 HTML코드로 설계된 웹 페이지가 브라우저에서 기능을 수행할 객체들로 실체화된 형태를 의미한다. Real DOM을 조작하는것은 불필요한 노드들을 처음부터 작성해야하는 문제가 있기에 SPA기반의 프레임워크나 라이브러리에선 가상 돔을 많이 사용한다.

가상 DOM은 실제 DOM을 모방하는 형태로 메모리 상에서만 존재하는 가상의 DOM을 의미한다. 실제 DOM에 변화가 적용되기 전에 가상의 DOM을 거쳐 미리 처리하고 저장된 후 실제 DOM에 업데이트하게 된다.

실제 DOM이 수정되면 Render Tree생성, Layout생성, Paint가 다시 이루어진다. 즉 리소스가 변경 될 때마다 전체 페이지를 갱신시키게 된다. 가상 DOM을 사용하면, 프레임워크마다 차이가 있지만, 가상 DOM의 변경점을 탐색하고 변경된 노드의 자식노드들의 변경점만 실제 DOM에 반영시키면서 불필요한 렌더링을 막게 된다.

## 14. 즐겨 보는 테크 유튜버나 뉴스레터가 있다면 알려주실 수 있을까요?

노마드 코더와 코딩애플, 리액트에 관련해서는 Web Dev Simplified를 자주 봅니다.

## 15. useRef 에 대해 아는 만큼 설명해주실 수 있을까요?

useRef는 리액트의 가상 DOM에 접근하기 위한 훅이다. 바닐라 javascript의 document.getElementBy* 함수처럼 원하는 문서 객체에 접근해 이벤트 리스너를 추가하거나, 문서 객체의 메소드를 사용하는 등의 역할을 한다.

리액트에서는 useRef를 사용하는것을 권장한다. 첫째로 자바스크립트의 방식은 실제 DOM에 접근하므로 가상DOM의 장점을 이용할 수 없다. 또한 useRef는 해당 컴포넌트 안에서만 접근이 가능하므로 리액트의 단방향 흐름을 역행하지 않아 코드를 유지보수하기 쉽게 만들어준다.

추가적으로 useRef.current는 값이 변경되어도 리렌더링이 되지 않기 때문에 값이 변해도 리렌더링을 시키고싶지 않은 변수를 useRef.current에 담아 사용하기도 한다.

## 16. 리액트 컴포넌트의 라이프사이클에 대해 설명해주실 수 있을까요?

React의 각 컴포넌트는 Mounting, Updating, Unmounting 세 개의 주요 단계를 통해 주기를 관리하고 관찰할 수 있다.

Mounting은 DOM에 요소를 붙이는 것을 의미한다. 그 다음 단계인 Updating은 컴포넌트가 업데이트 될 때를 의미한다. 마지막으로 컴포넌트를 DOM에서 제거하는 과정을 Unmounting이라고 한다.

완벽하지는 않지만, class형 리액트 컴포넌트에서 특정한 생명주기에 특정한 코드를 실행시키고 싶다면 useEffect()를 사용해 구현할 수 있다.

## 17. JSX란 무엇인가요?

JSX(JavaScript XML)는 Javascript에 XML을 추가한 확장한 문법이다. .js나 .jsx파일에서 리액트의 컴포넌트를 마치 HTML처럼 표현하기 위해 사용되는데 공식적인 자바스크립트 문법은 아니다. 따라서 브라우저에서 실행되기 전에 babel이라는 트랜스컴파일러를 이용해 일반 자바스크립트 형태의 코드로 변환된다.
 
자바스크립트 코드를 JSX문법 내에서 사용하기 위해서 중괄호로 코드를 감싸주면 된다. 그렇다고 모든 자바스크립트 문법을 사용할 수는 없는데, 대표적으로 if문과 for문이 있다. if문을 대체하기 위해 삼항연산자를 사용하며 for문을 대체하기 위해 Array의 map, filter, every, find등의 내장 메소드를 이용한다.

## 18. 최근에 본 기술 아티클에 대해 설명해주실 수 있을까요?

최근 Sveltekit이라는 웹 프레임워크에 대한 글을 읽었다. Svelte라는 오픈소스 웹 프레임워크의 개발 도구 통합을 목표로 개발되어 2022년 12월에 첫 버전이 공개되었다고 한다. Svelte와 Sveltekit의 관계는 React와 Next.js의 관계와 비슷하다.

Svelte는 가상 DOM이 아닌 실제 DOM을 사용한다. 앱을 런타임에서 실행하지 않고 빌드 시점에서 자바스크립트로 컴파일하기 때문에 속도가 빠르고 따로 라이브러리를 배포할 필요가 없어 간편한 장점이 있다.

또한 적은 양의 코드로 프로그램을 작성하는데 중점을 두어 일반적으로 리액트 컴포넌트가 스벨트 컴포넌트보다 40% 많은 양의 코드를 작성해야 한다고 한다.

## 19. 포트폴리오에서 시간복잡도를 낮춘 사례가 있다면 설명해주실 수 있을까요?

시간복잡도는 아니지만, 성능을 개선했던 사례가 있다. 특정한 영역을 같은 색으로 칠하는 floodfill 알고리즘이였는데, 기본적으로 floodfill 알고리즘은 해당하는 모든 픽셀에 적용되어야 하므로 시간복잡도가 O(n)에서 내려갈 수 없다.

그러나 성능을 개선하는 방법은 시간복잡도만 있는 것은 아니다. 첫째로 꼬리재귀로 작성된 알고리즘을 반복문을 통해서 구현하여 성능을 개선하였다. 그러나 이 역시도 Array의 pop과 push메소드의 오버헤드 때문에 만족할만한 성능을 내지는 못했다.

최종적으로 배열의 내장 메소드를 사용하지 않고 현재 픽셀의 위치를 담을 배열을 선언하여 포인터를 통해 알고리즘을 적용할 픽셀의 위치를 바꿔가며 구현하여 해결하였다. 또한 32비트의 정수로 표현된 RGBA값을 분리하기 위해 비트연산자 '&'로 원하는 비트를 마스킹하여 오른쪽으로 shift해 사용하여 성능을 개선시켰다.
