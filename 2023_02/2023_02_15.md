# 목터뷰(기술면접 준비)#3

## 29. TCP 3 way handshake란 무엇인지 설명해주실 수 있을까요?

TCP 3 Way Handshake는 TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방과 사전에 세션을 수립하는 과정을 의미한다.

클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보낸다. 클라이언트는 SYN/ACK 응답을 기다리는 SYN_SENT상태가 된다. 서버는 SYN 요청을 받고 클라이언트에게 요청을 수락한다는 SYN/ACK 패킷을 발송하고 클라이언트가 ACK으로 응답하기를 기다린다. 이 때 서버는 SYN_RECEIVED 상태가 된다.

마지막으로 클라이언트는 서버에게 ACK을 보내고 이후부터는 연결이 이루어지고 데이터가 오가게된다.

## 30. 우리 회사에 지원한 동기를 말씀해주실 수 있을까요?

저는 프로그램을 만들 때 항상 사용자의 눈높이에서 더 사용하기 편한 프로그램이 무엇인지를 생각하면서 코드를 작성하고자 합니다. 근무를 하면서 더 나은 사용자 경험을 제공하는 프론트엔드 개발자가 되고싶어 지원하게 되었습니다.

## 31. TCP 와 UDP 를 비교하여 설명해주실 수 있을까요?

TCP와 UDP모두 포트 번호를 이용해 주소를 지정하고, 데이터 오류 검사를 위한 체크섬이 존재한다.

그러나 UDP는 전송 순서가 보장되고, 수신 여부를 확인하는 등 신뢰성이 높은 TCP에 비해 전송 순서를 보장하지 않고 수신 여부를 확인하지 않아 신뢰성이 낮다. 하지만 신뢰성이 낮은 만큼 전송 속도가 빠르고 1:1 통신만 가능한 TCP와는 달리 1:1, 1:N, N:N 통신 모두 가능하다.

## 32. Base64 인코딩이란 무엇인가요?

바이너리 데이터를 문자 코드에 영향을 받지 않는 공통 ASCII문자로 표현하기 위해 만들어진 인코딩이다. ASCII 문자 하나가 64진법의 숫자 하나를 의미하기 때문에 Base64라는 이름을 가지게 되었다.

Base64의 인코딩 과정은 먼저 24비트의 버퍼를 생성해 바이트 데이터를 넣은 뒤 버퍼의 위쪽부터 6비트 단위로 잘라 Base64테이블의 ASCII문자로 변환한다. 다시 말해 원본 문자열 => ASCII binary => 6비트로 쪼갬 => Base64 인코딩 순서가 되고, 디코딩은 해당 과정을 반대로 진행하면 된다.

## 33. 프로세스와 스레드를 비교하여 설명해주실 수 있을까요?

프로세스는 운영체제로부터 시스템 자원을 할당받는 기본 단위이다. 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 의미한다. 프로세스는 각각 독립된 메모리 영역을 할당받게 되고, 각 프로세스는 별도의 주소 공간에서 실행된다.

스레드는 프로세스 내에서 실행되는 여러 흐름의 단위이다. 기본적으로 모든 프로세스는 최소 하나의 메인 스레드를 가지게 된다. 프로세스가 할당받은 자원을 이용하는 실행의 단위이고 프로세스 내의 stack을 제외한 주소 공간이나 자원들을 공유한다.

## 34. 즐겁고 행복했던 경험을 하나 이야기해주실 수 있을까요?

저는 여행을 좋아합니다. 현지에 가서 현지의 문화를 경험하고 사람들과 대화하며 새로운 경험을 쌓을 때 행복하다고 느낍니다. 여행을 다닐 때 모든 결정을 스스로 선택하고 결정하여 여행 경로나 일정을 만들었는데, 아마 저의 손으로 여행과 관련된 모든 결정을 해서 더 행복하고 재밌었던 것 같습니다.

## 35. 깊은 복사와 얕은 복사의 차이는 무엇이고 JS에서 각각을 구현하는 방법은 어떻게 되는지 설명해주실 수 있을까요?

변수에 원시값을 저장하면 변수의 메모리 공간에 실제 데이터 값이 저장된다. 할당된 변수를 조작하려고 하면 저장된 실제 값이 조작된다. 원시값이 아닌 모든 값(Object, Symbol)들은 독립된 메모리 공간에 값을 저장하고 변수에 저장된 메모리 공간의 참조값만 지정하게 된다. 그래서 할당된 변수를 조작하는 것은 객체를 조작하는 것이 아니라 해당 객체의 참조를 조작하는 것이다.

원시값을 복사하게 되면 복사를 하고 값을 수정해도 기존 원시값을 저장한 변수에는 영향을 끼치지 않는다. 이처럼 실제 값을 복사하는 것을 깊은 복사라고 한다. 참조값을 복사하게 되면 변수가 객체의 참조를 가리키고 있기 때문에 복사된 변수 또한 객체가 저장된 메모리 공간의 참조를 가리키고 있다. 따라서 복사를 하고 객체를 수정하면 두 변수는 같은 참조를 가리키고 있기 때문에 기존 객체를 저장한 변수에 영향을 끼친다. 이처럼 객체의 참조를 복사하는 것은 얕은 복사이다.

## 36. 개발자가 되기로 한 이유에 대해 말씀해주실 수 있을까요?

대학교 진학 과정에서 전공을 선택하면서 모든 입시 원서를 컴퓨터 관련 과에 작성했었다. 처음에는 어렸을 때 부터(6살) 집에 컴퓨터가 있었어서 컴퓨터와 굉장히 친했었고 따라서 컴퓨터 관련 과에 진학하겠다고 막연히 생각했었다. 그러나 전공공부를 하고나서 생각해보니 생각보다 적성에 잘 맞았다.

문제해결 과정에서 내가 생각한 방식대로 문제가 해결되면 정말 재밌었고, 또한 어렸을 때 부터 수학을 굉장히 좋아했었는데 수학적인 방법론을 동원해 문제에 적용시키는 것 자체가 정말 흥미로워서 개발자가 되기로 결정하게 되었다.

## 37. JS의 passed by value 와 passed by reference 에 대해 아는 만큼 설명해주실 수 있을까요?

call by value는 함수의 인자로 파라미터를 넘기면서 변수의 값을 복사해서 전달하고, call by reference는 함수의 파라미터로 변수의 주소를 전달하는 방식이다.

call by value는 원래의 값에 영향을 주지 않으므로 원래의 값이 변경되면 안되는 경우에 사용된다. call by reference는 주소를 전달하기 때문에 원래 변수의 값에도 영향을 주게 된다. 값을 복사하지 않고 주소값만 전달하므로 변수의 크기에 상관 없이 비용이 일정하다.

## 38. 고차 함수란 무엇인지 설명해주실 수 있을까요?

자바스크립트에서 함수는 일급 객체이다. 다른 함수의 인자로 전달될 수 있고, 함수의 결과로서 리턴될 수 있다. 고차 함수는 함수를 인자로서 받을 수 있고 함수의 형태로 리턴할 수 있는 함수를 의미한다. 즉 자바스크립트의 함수는 일급 객체이면서 고차함수이다.

이 때 인자로서 전달되는 함수를 콜백함수라고 부르며 함수를 리턴하는 함수를 커리함수라고 부르기도 한다.

## 39. 힘들고 쉽지 않았지만 극복한 경험을 하나 이야기해주실 수 있을까요?

5주동안 첫 해외여행을 가면서 모든 것을 스스로 해결해야 했다. 숙소나 이동수단 예약부터 관광지 예약과 같은 것 부터 시작해서 여행 상황에서 발생한 예상치 못한 상황들도 해결해야 했으며 이 모든 것들을 20대 초반의 어린 나이에 의지할 곳도 없이 이전에 많이 사용해 본적 없는 영어로 처리했어야 했다. 물론 첫 여행은 굉장히 재밌는 경험이였지만 여행을 다녀오는 과정은 생각보다 쉽지 않았었다.

## 40. 다음 함수의 결과의 예측과 근거를 설명해주실 수 있을까요? <함수 이미지 준비중 😅>

함수 이미지 없음

## 41. VanillaJS와 비교하여 리액트를 사용하는 이유에 대해 설명해주실 수 있을까요?

모든 라이브러리와 프레임워크들은 개발의 효율을 높이기 위해 존재한다. 인간의 실수를 줄이기 위해 객체지향과 같은 패러다임이 등장하였고 소프트웨어 공학의 발전으로 잘못된 소프트웨어 개발 방법론으로 생겨난 소프트웨어 위기들은 줄억갔다.

리액트 역시 이런 큰 흐름과 일맥상통한다고 생각한다. 리액트의 atomic 디자인 패턴은 인터페이스를 작고 단순한 요소로 분리해 컴포넌트의 재사용성을 높이고 컴포넌트 개발에 들어가는 시간을 단축시켰다. 또한 상위 컴포넌트에서 하위 컴포넌트로의 일방적인 Props 데이터 흐름은 데이터 추적과 디버깅을 더 쉽게 만들어준다.

그리고 가상 돔이란 개념을 차용함으로써 실제 돔에 코드상 변경된 부분만 반영하여 렌더링 속도가 빠르다는 장점도 리액트를 사용하는 이유가 될 것이다.

## 42. 상태의 불변성이 중요한 이유가 무엇인가요?

리액트는 가상 DOM을 업데이트 할 때 얕은 비교를 수행하여 업데이트한다. 따라서 상태값이 변할 때 새로운 참조를 전달하지 않고 참조된 변수의 값을 직접 변화시키면 리액트는 상태변화를 감지하지 못하고 DOM에 반영되지 않게된다! 따라서 배열이나 객체를 업데이트 할 때 [...state, newState]와 같은 형식으로 업데이트해야만 한다.

또한 상태의 불변성을 지킴으로써 외부에 존재하는 원본 데이터를 직접 수정하지 않고 원본 데이터의 복사본을 만들어 예상치 못한 오류를 미연에 방지하게 된다. 외부의 데이터를 변경시킴으로써 일어날 사이드이펙트를 막을 수 있게 된다.

## 43. Lazy loading과 Code splitting에 대해 아는 만큼 설명해주실 수 있을까요?
