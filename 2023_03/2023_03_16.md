# 2023.03.16 golang으로 서버를 구축하자 #2

- [조건문](#조건문)
  - [if문](#if문)
  - [switch문](#switch문)
- [반복문](#반복문)
- [함수](#함수)
  
## 조건문

### if문

if문은 해당 조건이 맞으면 블럭 안의 내용을 실행한다. 다른 언어의 if문과 큰 차이는 없다.

```go
if k == 1 {
    println("One")
} else if k == 2 {
    println("Two")
} else {
    println("Other")
}
```

go의 if문의 특징은, 조건식을 사용하기 이전에 간단한 문장을 함게 실행할 수 있다.

```go
if val := i * 2; val < max {
    println(val)
}
 
// 아래 처럼 사용하면 Scope 벗어나 에러
val++
```

주의해야할 점은, 조건문에서 선언된 변수는 if-else블럭 스코프 안에서만 사용할 수 있다.

### switch문

switch문 역시 기본적인 사용방법은 동일하다. 그러나 다른 언어와는 다른 특징들이 있다.

1. switch 뒤에 expression이 없을 수 있음

	다른 언어는 switch 키워드 뒤에 변수나 expression을 반드시 두지만, Go는 이를 쓰지 않아도 된다. 이 경우 Go는 switch expression을 true로 생각하고 첫번째 case문으로 이동하여 검사한다
	
2. case문에 expression을 쓸 수 있음

	다른 언어의 case문은 일반적으로 리터럴 값만을 갖지만, Go는 case문에 복잡한 expression을 가질 수 있다
	
3. No default fall through

	다른 언어의 case문은 break를 쓰지 않는 한 다음 case로 이동하지만, Go는 다음 case로 가지 않는다
	
4. Type switch

	다른 언어의 switch는 일반적으로 변수의 값을 기준으로 case로 분기하지만, Go는 그 변수의 Type에 따라 case로 분기할 수 있다

***

switch문에 변수 혹은 expression을 적지 않으면 각 case 조건문들을 순서대로 검사하여 조건에 맞는 경우 해당 case블럭을 실행하고 switch문을 빠져나온다. 복잡한 if-else if-else if...문을 단순화하는데 유용하다

```go
func grade(score int) {
    switch {
    case score >= 90:
        println("A")
    case score >= 80:
        println("B")
    case score >= 70:
        println("C")
    case score >= 60:
        println("D")
    default:
        println("No Hope")
    }
}   
```

또한 go는 switch 변수의 type을 검사할 수 있다. 밑의 코드는 변수 v의 타입이 int, bool, string인지 체크하는 코드이다.

```go
switch v.(type) {
case int:
    println("int")
case bool:
    println("bool")
case string:
    println("string")
default:
    println("unknown")
}   
```

go의 컴파일러는 각 케이스 블럭의 마지막에 자동으로 break를 추가하기 때문에 break를 작성하지 않아도 switch문을 빠져나온다. 만약 다른 언어들처럼 break를 작성하지 않고 다음 case문을 실행시키고 싶다면 fallthrough를 추가해주면 된다.

```go
func check(val int) {
    switch val {
    case 1:
        fmt.Println("1 이하")
        fallthrough
    case 2:
        fmt.Println("2 이하")
        fallthrough
    case 3:
        fmt.Println("3 이하")
        fallthrough
    default:
        fmt.Println("default 도달")
    }
}
```

## 반복문

go에는 오로지 for밖에 없다! javascript에 있는 for each, for in, for of 그리고 배열의 map reduce filter와 같은 것들은 존재하지 않는다.

<b>for문</b>

for문은 초기값; 조건식; 증감을 둘러싸는 괄호를 생략한다.

```go
sum := 0
for i := 1; i <= 100; i++ {
    sum += i
}
println(sum)
```

<b>조건식만 쓰는 for</b>

초기값과 증감식을 생략할 수 있다. 이는 for루프가 다른 언어의 while 루프와 비슷하게 동작하게 한다.

```go
n := 1
for n < 100 {
    n *= 2
}
println(n)
```

<b>무한루프</b>

for로 무한루프를 만들고 싶으면 초기값 조건식 증감 모두를 생략하면 된다.

```go
for {
	println("Infinite loop")
}
```

<b>for range문</b>

for range문은 컬렉션으로부터 한 요소씩 가져와 차례로 for블럭의 코드를 실행한다. foreach와 비슷하다고 생각하면 된다.

```go
names := []string{"홍길동", "이순신", "강감찬"}
 
for index, name := range names {
    println(index, name)
}
```






















