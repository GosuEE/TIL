# 코딩테스트 연습

## 부대 복귀

### 문제 설명
강철부대의 각 부대원이 여러 지역에 뿔뿔이 흩어져 특수 임무를 수행 중입니다. 지도에서 강철부대가 위치한 지역을 포함한 각 지역은 유일한 번호로 구분되며, 두 지역 간의 길을 통과하는 데 걸리는 시간은 모두 1로 동일합니다. 임무를 수행한 각 부대원은 지도 정보를 이용하여 최단시간에 부대로 복귀하고자 합니다. 다만 적군의 방해로 인해, 임무의 시작 때와 다르게 되돌아오는 경로가 없어져 복귀가 불가능한 부대원도 있을 수 있습니다.

강철부대가 위치한 지역을 포함한 총지역의 수 n, 두 지역을 왕복할 수 있는 길 정보를 담은 2차원 정수 배열 roads, 각 부대원이 위치한 서로 다른 지역들을 나타내는 정수 배열 sources, 강철부대의 지역 destination이 주어졌을 때, 주어진 sources의 원소 순서대로 강철부대로 복귀할 수 있는 최단시간을 담은 배열을 return하는 solution 함수를 완성해주세요. 복귀가 불가능한 경우 해당 부대원의 최단시간은 -1입니다.

### 제한사항
	3 ≤ n ≤ 100,000
		각 지역은 정수 1부터 n까지의 번호로 구분됩니다.
	2 ≤ roads의 길이 ≤ 500,000
		roads의 원소의 길이 = 2
		roads의 원소는 [a, b] 형태로 두 지역 a, b가 서로 왕복할 수 있음을 의미합니다.(1 ≤ a, b ≤ n, a ≠ b)
		동일한 정보가 중복해서 주어지지 않습니다.
			동일한 [a, b]가 중복해서 주어지지 않습니다.
			[a, b]가 있다면 [b, a]는 주어지지 않습니다.
	1 ≤ sources의 길이 ≤ 500
		1 ≤ sources[i] ≤ n
	1 ≤ destination ≤ n

### 접근

주어진 그래프는 무방향 그래프이므로 출발지에서 도착지까지의 거리는 도착지에서 출발지까지의 거리와 같다. 즉, 도착지에서 모든 출발지에 대한 거리를 구하면 해당 문제는 해결이 되므로 이는 다익스트라를 활용한 문제라고 할 수 있을 것이다.

또한 모든 가중치의 값은 1이므로 생각보다 간단하게 구현이 가능해진다.

### 오류와 해결

아무래도 자바스크립트 객체는 자바의 객체와 많이 달라서 그런가 구현중에 많은 오류가 있었다. 예를 들면 함수 내부에 var을 이용해 생성한 변수는 함수가 끝나면 사라지므로 함수 외부에서 사용할 수 없고, 객체 프로퍼티를 통하여 정의해도 Array()가 아직 생성된것이 아니라 함수 내에서 array.push등 메소드를 이용할 수 없는 문제가 있었다.

그래서 객체의 프로퍼티에 this를 추가하고 이후 해당 프로퍼티를 사용할 때 마다 this를 추가해주니 잘 실행이 되었다. 왜 this로 명확히 지정해주어야 사용이 가능한지는 찾아봐야겠다.

### 코드

```javascript
function solution(n, roads, sources, destination) {

    var g = new Graph(n + 1);
    var dis = new Array(n + 1);
    dis.fill(Infinity);

    for (let i = 0; i < roads.length; i++) {
        let a = roads[i][0];
        let b = roads[i][1];

        g.nodes[a].connections.push(b);
        g.nodes[b].connections.push(a);
    }

    dijkstra(g, dis, destination, n)

    var answer = [];
    for (let i = 0; i < sources.length; i++)
        answer.push(dis[sources[i]] == Infinity ? -1 : dis[sources[i]]);
    console.log(answer);
    return answer;
}

function dijkstra(graph, dis, destination, n) {
    var queue = [];
    var isVisited = new Array(n);

    queue.push(destination);
    isVisited[destination] = true;
    dis[destination] = 0;

    while (!(queue.length == 0)) {
        var thisNode = queue.shift();
        for (let i = 0; i < graph.nodes[thisNode].connections.length; i++) {
            var newNode = graph.nodes[thisNode].connections[i]
            if (!isVisited[newNode]) {
                
                queue.push(newNode);
                isVisited[newNode] = true;
                if (dis[newNode] > dis[thisNode] + 1)
                    dis[newNode] = dis[thisNode] + 1;
            }
        }
    }
}

function List() {
    this.connections = [];
}

function Graph(num) {
    this.nodes = [];

    for (let i = 0; i < num; i++)
        this.nodes.push(new List());
}
```
일단, 모든 연결을 2차원 배열로 나타내는것은 비효율적이므로 간단한 Graph와 List 자료구조를 구현했다. Graph는 각 노드를 저장하는 배열을 프로퍼티로 가지고 있고 List는 다른 노드와의 커넥션을 가지고 있다.

```javascript
for (let i = 0; i < roads.length; i++) {
	let a = roads[i][0];
	let b = roads[i][1];

	g.nodes[a].connections.push(b);
	g.nodes[b].connections.push(a);
}

```

roads에 저장되어있는 연결들을 그래프의 노드로 옮겨주는 작업이다.

```javascript
function dijkstra(graph, dis, destination, n) {
    var queue = [];
    var isVisited = new Array(n);

    queue.push(destination);
    isVisited[destination] = true;
    dis[destination] = 0;

    while (!(queue.length == 0)) {
        var thisNode = queue.shift();
        for (let i = 0; i < graph.nodes[thisNode].connections.length; i++) {
            var newNode = graph.nodes[thisNode].connections[i];
            if (!isVisited[newNode]) {               
                queue.push(newNode);
                isVisited[newNode] = true;
                if (dis[newNode] > dis[thisNode] + 1)
                    dis[newNode] = dis[thisNode] + 1;
            }
        }
    }
}
```

다익스트라 알고리즘을 실행하는 코드다.
도착지 노드에서 알고리즘을 시작한다. 큐에 도착지 노드를 넣고 방문을 true로 설정하고 자기 자신의 거리를 0으로 설정했다.

이후 큐가 빌 때 까지 while문을 실행한다. 큐에서 빼온 노드를 현재 노드로 설정하고 현재 노드와 연결된 모든 노드들을 순회한다 만일 이미 방문이 되었으면 다음 노드를 살펴보고, 방문이 되지 않았다면 새로운 노드를 큐에 push하고 방문을 설정한다.

새로운 노드의 distance값과 현재 노드+거리(1)값을 비교해 현재 노드+거리의 값이 더 작으면 새로운 노드의 dintance값을 현재노드+거리 값으로 설정해준다.

이 과정을 통해 dist에서 연결된 모든 노드까지의 거리를 알 수 있고, 만일 연결되지 않았다면 기본 distance값을 Infinity로 설정했기 때문에 거리는 무한대가 된다.

```javascript
var answer = [];
for (let i = 0; i < sources.length; i++)
	answer.push(dis[sources[i]] == Infinity ? -1 : dis[sources[i]]);
console.log(answer);
return answer;
}
```

만일 거리값이 무한대라면 answer에 -1을 저장하고 그렇지 않으면 거리값을 저장한다. 이후 answer배열을 return해주면 끝난다.
