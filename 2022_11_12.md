# 코딩테스트 연습

## 부대 복귀

### 문제 설명
강철부대의 각 부대원이 여러 지역에 뿔뿔이 흩어져 특수 임무를 수행 중입니다. 지도에서 강철부대가 위치한 지역을 포함한 각 지역은 유일한 번호로 구분되며, 두 지역 간의 길을 통과하는 데 걸리는 시간은 모두 1로 동일합니다. 임무를 수행한 각 부대원은 지도 정보를 이용하여 최단시간에 부대로 복귀하고자 합니다. 다만 적군의 방해로 인해, 임무의 시작 때와 다르게 되돌아오는 경로가 없어져 복귀가 불가능한 부대원도 있을 수 있습니다.

강철부대가 위치한 지역을 포함한 총지역의 수 n, 두 지역을 왕복할 수 있는 길 정보를 담은 2차원 정수 배열 roads, 각 부대원이 위치한 서로 다른 지역들을 나타내는 정수 배열 sources, 강철부대의 지역 destination이 주어졌을 때, 주어진 sources의 원소 순서대로 강철부대로 복귀할 수 있는 최단시간을 담은 배열을 return하는 solution 함수를 완성해주세요. 복귀가 불가능한 경우 해당 부대원의 최단시간은 -1입니다.

### 제한사항
	3 ≤ n ≤ 100,000
		각 지역은 정수 1부터 n까지의 번호로 구분됩니다.
	2 ≤ roads의 길이 ≤ 500,000
		roads의 원소의 길이 = 2
		roads의 원소는 [a, b] 형태로 두 지역 a, b가 서로 왕복할 수 있음을 의미합니다.(1 ≤ a, b ≤ n, a ≠ b)
		동일한 정보가 중복해서 주어지지 않습니다.
			동일한 [a, b]가 중복해서 주어지지 않습니다.
			[a, b]가 있다면 [b, a]는 주어지지 않습니다.
	1 ≤ sources의 길이 ≤ 500
		1 ≤ sources[i] ≤ n
	1 ≤ destination ≤ n

### 접근

주어진 그래프는 무방향 그래프이므로 출발지에서 도착지까지의 거리는 도착지에서 출발지까지의 거리와 같다. 즉, 도착지에서 모든 출발지에 대한 거리를 구하면 해당 문제는 해결이 되므로 이는 다익스트라를 활용한 문제라고 할 수 있을 것이다.

또한 모든 가중치의 값은 1이므로 생각보다 간단하게 구현이 가능해진다.

### 오류와 해결

아무래도 자바스크립트 객체는 자바의 객체와 많이 달라서 그런가 구현중에 많은 오류가 있었다. 예를 들면 함수 내부에 var을 이용해 생성한 변수는 함수가 끝나면 사라지므로 함수 외부에서 사용할 수 없고, 객체 프로퍼티를 통하여 정의해도 Array()가 아직 생성된것이 아니라 함수 내에서 array.push등 메소드를 이용할 수 없는 문제가 있었다.

ㄱ래서 객체의 프로퍼티에 this를 추가하고 이후 해당 프로퍼티를 사용할 때 마다 this를 추가해주니 잘 실행이 되었다. 왜 this로 명확히 지정해주어야 사용이 가능한지는 찾아봐야겠다.

### 코드

```
function solution(n, roads, sources, destination) {

    var g = new Graph(n + 1);
    var dis = new Array(n + 1);
    dis.fill(Infinity);

    for (let i = 0; i < roads.length; i++) {
        let a = roads[i][0];
        let b = roads[i][1];

        g.nodes[a].connections.push(b);
        g.nodes[b].connections.push(a);
    }

    dijkstra(g, dis, destination, n)

    var answer = [];
    for (let i = 0; i < sources.length; i++)
        answer.push(dis[sources[i]] == Infinity ? -1 : dis[sources[i]]);
    console.log(answer);
    return answer;
}

function dijkstra(graph, dis, destination, n) {
    var queue = [];
    var isVisited = new Array(n);

    queue.push(destination);
    isVisited[destination] = true;
    dis[destination] = 0;

    while (!(queue.length == 0)) {
        var thisNode = queue.shift();
        for (let i = 0; i < graph.nodes[thisNode].connections.length; i++) {
            var newNode = graph.nodes[thisNode].connections[i]
            if (!isVisited[newNode]) {
                
                queue.push(newNode);
                isVisited[newNode] = true;
                if (dis[newNode] > dis[thisNode] + 1)
                    dis[newNode] = dis[thisNode] + 1;
            }
        }
    }
}

function List() {
    this.connections = [];
}

function Graph(num) {
    this.nodes = [];

    for (let i = 0; i < num; i++)
        this.nodes.push(new List());
}
```
