# 프로토타입, 상속, bind(), SSR & CSR

## 프로토타입과 상속

### 프로토타입

자바스크립트는 클래스개념이 없는 언어이다. 그래서 기존의 객체를 복사하여 새로운 객체를 생성하는, 프로토타입 기반의 방식을 사용한다. 프로토타입 기반 언어는 객체 원형인 프로토타입을 이용해 새로운 객체를 만들어내고, 이렇게 생성된 객체 역시 다른 객체의 원형이 될 수 있다. 프로토타입은 객체지향적인 프로그래밍을 할 수 있게 해준다.

![01](./2022_11_10_img/01.png)

```javascript
function Person(){};
```
자바스크립트에서는 함수를 정의하면 내부에 prototype 변수가 생긴다. 이 변수는 함수 이름의 프로토타입 객체를 참조하고, 프로토타입 객체의 멤버인 constructor 변수는 함수를 참조하는 내부구조를 가진다.

![02](./2022_11_10_img/02.png)

```javascript
function Person(){};
var joon = new Person();
var jisoo = new Person();
```

여기서 함수의 prototype 속성이 참조하는 프로토타입 객체는 new 연산자와 person함수를 통해 생성된 모든 객체의 원형이 되는 객체이다. 

또한 생성된 모든 객체들은 __proto__ 속성을 통해 프로토타입 객체를 참조한다.

자바스크립트에선 boolean, number, string, null, undefined를 제외하고는 모두 객체이다. 객체 안에는 __proto__라는 속성이 있고 원형인 프로토타입 객체를 참조한다.

모든 객체는 자신의 프로토타입 객체에 접근할 수 있고 프로토타입 역시 객체이므로 동적으로 런타임에 멤버를 추가할 수 있다. 또한 같은 프로토타입을 복사해 생성된 모든 객체는 추가된 멤버를 사용할 수 있다.

![03](./2022_11_10_img/03.png)

```javascript
function Person(){};
var joon = new Person();
var jisoo = new Person();

Person.prototype.getType = function(){
	return "사람";
}

console.log(joon.getType()) // 사람
console.log(jisoo.getType()) // 사람
```
prototype을 이용해 getType()함수를 추가했지만 추가하기 이전의 joon과 jisoo객체에서도 getType이 사용 가능하다.
또한 프로토타입 객체에 멤버를 추가,수정,삭제할때는 함수 안의 prototype속성을 사용해야한다. 하지만 prototype 객체를 읽을 때는 함수 안의 prototype속성 또는 객체 이름으로 접근해야한다.

![04](./2022_11_10_img/04.png)

```javascript
joon.getType = function(){
	return "인간"
}

console.log(joon.getType()) // 인간
console.log(jisoo.getType()) // 사람

jisoo.age = 25;

console.log(joon.age) // undefined
console.log(jisoo.age) // 25
```

joon의 getType()을 수정하였고, joon에는 getType()이라는 메소드가 존재하므로 joon.getType()을 호출하면 joon의 getType이 호출된다. 반대로 jisoo에는 getType()이 없으므로 __proto__에 참조되어있는 protoType객체의 getType()이 호출된다.

jisoo에 age 속성을 추가하고 joon.age를 출력하면 joon과 프로토타입 모두 age라는 속성이 없으므로 undefined가 출력된다. 그러나 jisoo는 age속성을 가지고 있으므로 25가 출력된다.

### 상속

크게 두 가지의 방식으로 상속이 가능하다. 하나는 new를 이용한 classical 방식이고 다른 하나는 Object.create()를 이용한 prototypal이다.

1. 기본 방법

![05](./2022_11_10_img/05.png)

```javascript
function Person(name){
    this.name = name || "혁준";
}

Person.prototype.getName = function(){
    return this.name;
}

function Korean(name){}

Korean.prototype = new Person();

var kor1 = new Korean();
console.log(kor1.getName());

var kor2 = new Korean("지수");
console.log(kor1.getName());
```

kor1객체의 __proto__를 new Person()객체로 지정하고, Person 프로토타입 객체에 getName()메소드를 추가한 상황이다.

kor2에 지수라는 인자를 전달하였으나 getName()으로 name을 부르면 혁준이 반환된다. 이는 자식 객체를 생성할 때 인자를 넘겨도 부모 객체를 생성할때 인자를 넘겨 줄 수 없어 기본값인 혁준이 this.name에 저장되기 때문이다. 객체를 생성할 때 마다 부모의 함수를 호출할 수도 있으나 이는 매우 비효율적이다.

또한 이 방식은 부모 객체의 속성과 부모 객체의 프로토타입 속성 모두를 물려받게 된다. 대부분의 경우 객체 자신의 속성은 특정 인스턴스에 한정되어 재사용할 수 없어 필요가 없다.

2. 생성자 빌려 쓰기


## bind와 함수, 메소드 ,컨택스트

## SSR과 CSR
