# React 팀과제, React 생명주기, Redux

## 리액트 팀과제

### 1번 문제

```
부모 컴포넌트 A와 자식 컴포넌트 B가 있습니다.
컴포넌트 A는 state로 {name: "르탄이"}를 가지고 있고, 자식인 컴포넌트 B에게 name 값을 넘겨주었습니다.
컴포넌트 B는 받아온 name을 화면에 뿌려주고 있습니다.
컴포넌트 A의 state가 {name: "진도사우르스"}로 바뀌었을 때, 어떤 과정을 거쳐 바뀐 값을 화면에 보여주는 지 라이프 사이클 흐름을 그려볼까요?
```

컴포넌트는 생성(mounting), 업데이트(updating), 제거(unmounting)의 생명주기를 갖는다. 리액트 클래스 컴포넌트는 라이프사이클 메서드를 사용하고, 함수형 컴포넌트는 Hook을 사용해 특정 라이프 사이클 지점에서 코드를 호출할 수 있다.

위의 경우에는 컴포넌트가 이미 존재한다고 가정하였고, 컴포넌트를 삭제하지 않았기 때문에 업데이트 라이프 사이클만 고려하면 된다. 리액트에서 업데이트가 발생하는 경우는 다음의 네 가지이다.

1. props가 바뀔 때
2. state가 바뀔 때
3. 부모 컴포넌트가 리렌더링 할 때
4. this.forceUpdate로 강제 렌더링을 트리거 할 때

처음, 컴포넌트 A의 state가 바뀌었으므로 A가 리렌더링 된다. A가 리렌더링 되면 B에 새로운 props를 내려주기 때문에 B도 리렌더링된다. 

렌더 단계에 들어가면 새로운 가상 DOM을 생성한 뒤 이전 가상 DOM과 비교하여 실제 DOM에 반영할 부분을 결정한다. 이후 커밋 단계에서 달라진 부분만 실제 DOM에 반영한다. 위 상황에서는 컴포넌트 B에서 달라진 name을 화면에 뿌려주는 부분이 실제 DOM에 반영될 것이다.

브라우저가 화면에 Paint하기 전에, useLayoutEffect에 등록해둔 effect가 있다면 실행한다. 이 때 state, redux store등의 변경이 있다면 한번 더 재렌더링 된다.

이후 Paint과정에서 브라우저가 실제 DOM을 화면에 그리게 되면 끝나게 된다.

만일 각 컴포넌트에 다음과 같은 생명주기 메소드들이 존재한다면, 메소드들이 해당하는 시점에 실행 될 것이다. 그러나 위 문제에서는 별개의 언급이 없어 추가하지 않았다.

1. getDerivedStateFromProps()

	업데이트 단계에서 가장 먼저 호출되는 메소드이다. 초기 props에 기반한 state가 저장되는 곳이다. 주로 props의 변화에 따라 state값에도 변화를 주고 싶을 때 사용한다.

2. shouldComponentUpdate()

	React가 렌더링을 계속해야하는지 마는지에 대한 진리값을 반환하다. 기본값은 true이고 false를 리턴하면 컴포넌트는 업데이트 되지 않는다.

3. render()

	모든 클래스형 컴포넌트가 반드시 가져야 하는 메소드이다. 컴포넌트가 업데이트 되면 render()함수가 호출되고 새로운 변경점들을 갖고 리렌더링 된다.

4. getSnapshotBeforeUpdate()

	render에서 만들어진 결과물이 브라우저에 실제로 반영되기 직전 호출된다. 그러므로 업데이트 되기 전의 props와 state에 접근할 수 있다.

5. componentDidUpdate()

	컴포넌트의 업데이트 작업이 끝난 후 호출되는 메소드이다.
***
### 2번 문제

```
양방향 바인딩은 무엇일까요? 
양방향 바인딩을 사용하는 경우 리렌더링이 어떻게 이루어질 지 그려보세요.
(부모 컴포넌트 A와 자식 컴포넌트 B가 있음을 가정하고 그려봅시다.)
```

![01](./2022_11_30_img/01.png)

양방향 바인딩에서는 부모 컴포넌트와 자식 컴포넌트간에 데이터가 서로 양방향으로 흐른다. 부모와 자식 모두 데이터를 직접 변경할 수 있다.

model(JavaScript)과 view(HTML)가 있을 때, 양방향 데이터 바인딩은 model이 업데이트 되면 view가 업데이트 되고, 반대로 view가 업데이트되면 model이 업데이트 되는 것이다.

리액트에서의 양방향 바인딩은, 자식 컴포넌트에서 event가 발생할 때 부모 컴포넌트에서 전달한 핸들러를 통해 부모 컴포넌트의 state를 바꾸어 양방향 바인딩과 같은 동작이 일어나게 함으로써 작동한다. 이를 state 끌어올리기(lifting state up)이라고 한다.

자식 컴포넌트 B에서 state 끌어올리기를 통해 부모 컴포넌트의 state를 변경시키면, 부모 컴포넌트가 리렌더링 되고 부모 컴포넌트가 리렌더링 되었으므로 자식 컴포넌트도 리렌더링된다. 

그러나 리액트에서 양방향 바인딩 사용은 권장되지 않는다. 넘겨주는 데이터가 부모에서 바뀌고, 그것이 다시 자식컴포넌트로 내려보내는 props 값이고, 그것이 event를 발생시켜 핸들러를 호출한다면 무한 루프에 빠지게 될 수 있다.

또한 컴포넌트의 구조가 복잡해진다면 유지보수가 힘들어지고, 자식 컴포넌트에서 부모 컴포넌트의 state를 변경하는 경우 해당 state 변수를 갖고있는 부모 컴포넌트까지 리렌더링이 일어나므로 효율적이지 못하다.

![02](./2022_11_30_img/02.gif)

말단 컴포넌트에서 발생한 state change가 root 컴포넌트까지 올라가서 전체 페이지를 리렌더링 시키는 모습을 볼 수 있다. 이런 상황을 방지하기 위해서 redux와 같은 상태변화 라이브러리들을 사용한다.
***
### 3번 문제

```
event listener는 등록되면 반드시 해제되어야 합니다.
클래스형 컴포넌트에서는 컴포넌트가 화면에서 사라질 때(unmount 될 때) event listener를 해제합니다. (componentWillUnmount에서요!)
그럼 라이프사이클 메소드를 사용할 수 없는 함수형 컴포넌트에서는 event listener를 해제할 때 어떻게 해야할까요?
```
